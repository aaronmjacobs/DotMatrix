#include "Core/Assert.h"
#include "Core/Enum.h"

#include "GBC/Cartridge.h"
#include "GBC/GameBoy.h"
#include "GBC/Memory.h"

#include <cstring>

namespace GBC
{

namespace
{

const std::array<uint8_t, 256> kBootstrap =
{
   0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32,
   0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
   0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3,
   0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
   0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A,
   0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
   0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06,
   0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
   0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99,
   0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
   0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64,
   0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
   0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90,
   0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
   0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62,
   0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
   0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42,
   0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
   0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04,
   0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
   0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
   0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
   0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
   0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
   0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
   0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
   0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
   0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
   0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13,
   0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
   0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20,
   0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50,
};

} // namespace

// static
const uint8_t Memory::kInvalidAddressByte;

Memory::Memory(GameBoy& gb)
   : raw{}
   , cart(nullptr)
   , gameBoy(gb)
{
   // If no cartridge is available, all cartridge reads return 0xFF
   romb.fill(0xFF);
   roms.fill(0xFF);
   eram.fill(0xFF);
}

uint8_t Memory::readDirect(uint16_t address) const
{
   uint8_t value = kInvalidAddressByte;

   if (boot == Enum::cast(Boot::Booting) && address <= 0x00FF)
   {
      value = kBootstrap[address];
   }
   else if ((address >= 0x8000 && address <= 0x9FFF) || (address >= 0xFE00 && address <= 0xFEFF) || (address >= 0xFF40 && address <= 0xFF4F))
   {
      value = gameBoy.getLCDController().read(address);
   }
   else if (cart && address < 0x8000)
   {
      value = cart->read(address);
   }
   else if (cart && address >= 0xA000 && address < 0xC000)
   {
      value = cart->read(address);
   }
   else if (address >= 0xFF10 && address < 0xFF40)
   {
      // Sound registers
      value = gameBoy.getSoundController().read(address);
   }
   else
   {
      if (address >= 0xE000 && address < 0xFE00)
      {
         // Mirror of working ram
         address -= 0x2000;
      }

      value = raw[address];

      if (address == 0xFF0F)
      {
         // IF reads are masked (upper 3 bits are unused)
         value |= 0xE0;
      }
   }

   return value;
}

void Memory::writeDirect(uint16_t address, uint8_t value)
{
   if (boot == Enum::cast(Boot::Booting) && address <= 0x00FF)
   {
      // Bootstrap is read only
   }
   else if ((address >= 0x8000 && address <= 0x9FFF) || (address >= 0xFE00 && address <= 0xFEFF) || (address >= 0xFF40 && address <= 0xFF4F))
   {
      gameBoy.getLCDController().write(address, value);
   }
   else if (cart && address < 0x8000)
   {
      cart->write(address, value);
   }
   else if (cart && address >= 0xA000 && address < 0xC000)
   {
      cart->write(address, value);
   }
   else if (address >= 0xFF10 && address < 0xFF40)
   {
      // Sound registers
      gameBoy.getSoundController().write(address, value);
   }
   else
   {
      if (address >= 0xE000 && address < 0xFE00)
      {
         // Mirror of working ram
         address -= 0x2000;
      }

      if (address == 0xFF04)
      {
         // Divider register
         gameBoy.onDivWrite();
      }

      if (address == 0xFF05)
      {
         // TIMA
         gameBoy.onTimaWrite();

         // If TIMA was reloaded with TMA this machine cycle, the write is ignored
         if (gameBoy.wasTimaReloadedWithTma())
         {
            return;
         }
      }

      if (address == 0xFF06 && gameBoy.wasTimaReloadedWithTma())
      {
         // TMA

         // If TIMA was reloaded with TMA this machine cycle, then the value written to TMA gets propagated to TIMA as well
         tima = value;
      }

      if (address == 0xFF0F)
      {
         // IF
         gameBoy.onIfWrite();
      }

      if (address == 0xFF41)
      {
         // LCD status - mode flag should be unaffected by memory writes
         static const uint8_t kModeFlagMask = 0b00000011;
         value = (value & ~kModeFlagMask) | (stat & kModeFlagMask);
      }

      raw[address] = value;
   }
}

uint8_t Memory::read(uint16_t address) const
{
   gameBoy.machineCycle();

   return readDirect(address);
}

void Memory::write(uint16_t address, uint8_t value)
{
   gameBoy.machineCycle();

   writeDirect(address, value);
}

} // namespace GBC
